<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · SolverBenchmark.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SolverBenchmark.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">SolverBenchmark.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Tables-1"><span>Tables</span></a></li><li><a class="tocitem" href="#Profiles-1"><span>Profiles</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSmoothOptimizers/SolverBenchmark.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-1"><a class="docs-heading-anchor" href="#Tutorial-1">Tutorial</a><a class="docs-heading-anchor-permalink" href="#Tutorial-1" title="Permalink"></a></h1><p>In this tutorial we illustrate the main uses of <code>SolverBenchmark</code>.</p><p>First, let&#39;s create fake data. It is imperative that the data for each solver be stored in <code>DataFrame</code>s, and the collection of different solver must be stored in a dictionary of <code>Symbol</code> to <code>DataFrame</code>.</p><p>In our examples we&#39;ll use the following data.</p><pre><code class="language-julia">using DataFrames, Printf, Random

Random.seed!(0)

n = 10
names = [:alpha, :beta, :gamma]
stats = Dict(name =&gt; DataFrame(:id =&gt; 1:n,
         :name =&gt; [@sprintf(&quot;prob%03d&quot;, i) for i = 1:n],
         :status =&gt; map(x -&gt; x &lt; 0.75 ? :success : :failure, rand(n)),
         :f =&gt; randn(n),
         :t =&gt; 1e-3 .+ rand(n) * 1000,
         :iter =&gt; rand(10:10:100, n),
         :irrelevant =&gt; randn(n)) for name in names)</code></pre><pre><code class="language-none">Dict{Symbol,DataFrames.DataFrame} with 3 entries:
  :alpha =&gt; 10×7 DataFrames.DataFrame…
  :beta  =&gt; 10×7 DataFrames.DataFrame…
  :gamma =&gt; 10×7 DataFrames.DataFrame…</code></pre><p>The data consists of a (fake) run of three solvers <code>alpha</code>, <code>beta</code> and <code>gamma</code>. Each solver has a column <code>id</code>, which is necessary for joining the solvers (names can be repeated), and columns <code>name</code>, <code>status</code>, <code>f</code>, <code>t</code> and <code>iter</code> corresponding to problem results. There is also a column <code>irrelevant</code> with extra information that will not be used to produce our benchmarks.</p><p>Here are the statistics of solver <code>alpha</code>:</p><pre><code class="language-julia">stats[:alpha]</code></pre><table class="data-frame"><thead><tr><th></th><th>id</th><th>name</th><th>status</th><th>f</th><th>t</th><th>iter</th><th>irrelevant</th></tr><tr><th></th><th>Int64</th><th>String</th><th>Symbol</th><th>Float64</th><th>Float64</th><th>Int64</th><th>Float64</th></tr></thead><tbody><p>10 rows × 7 columns</p><tr><th>1</th><td>1</td><td>prob001</td><td>failure</td><td>-0.688907</td><td>62.3686</td><td>70</td><td>0.891315</td></tr><tr><th>2</th><td>2</td><td>prob002</td><td>failure</td><td>-0.762804</td><td>353.13</td><td>10</td><td>-2.29449</td></tr><tr><th>3</th><td>3</td><td>prob003</td><td>success</td><td>0.397482</td><td>767.603</td><td>10</td><td>-1.17303</td></tr><tr><th>4</th><td>4</td><td>prob004</td><td>success</td><td>0.81163</td><td>43.142</td><td>80</td><td>-0.879915</td></tr><tr><th>5</th><td>5</td><td>prob005</td><td>success</td><td>-0.346355</td><td>267.986</td><td>30</td><td>-0.494043</td></tr><tr><th>6</th><td>6</td><td>prob006</td><td>success</td><td>-0.187573</td><td>66.8474</td><td>80</td><td>0.511959</td></tr><tr><th>7</th><td>7</td><td>prob007</td><td>success</td><td>-1.60726</td><td>156.638</td><td>60</td><td>-0.758701</td></tr><tr><th>8</th><td>8</td><td>prob008</td><td>success</td><td>-2.48079</td><td>605.298</td><td>40</td><td>-0.76796</td></tr><tr><th>9</th><td>9</td><td>prob009</td><td>success</td><td>2.27623</td><td>135.746</td><td>40</td><td>-0.0303032</td></tr><tr><th>10</th><td>10</td><td>prob010</td><td>failure</td><td>0.219693</td><td>838.119</td><td>50</td><td>-1.31924</td></tr></tbody></table><h2 id="Tables-1"><a class="docs-heading-anchor" href="#Tables-1">Tables</a><a class="docs-heading-anchor-permalink" href="#Tables-1" title="Permalink"></a></h2><p>The first thing we may want to do is produce a table for each solver. Notice that the solver result is already a DataFrame, so there are a few options available in other packages, as well as simply printing the DataFrame. Our concern here is two-fold: producing publication-ready LaTeX tables, and web-ready markdown tables.</p><p>The simplest use is <code>foo_table(io, dataframe)</code>. Here is printout to the <code>stdout</code>:</p><pre><code class="language-julia">using SolverBenchmark

markdown_table(stdout, stats[:alpha])</code></pre><pre><code class="language-none">|    id |    name |  status |        f |        t |  iter | irrelevant |
|-------|---------|---------|----------|----------|-------|------------|
|     1 | prob001 | failure | -6.9e-01 |  6.2e+01 |    70 |    8.9e-01 |
|     2 | prob002 | failure | -7.6e-01 |  3.5e+02 |    10 |   -2.3e+00 |
|     3 | prob003 | success |  4.0e-01 |  7.7e+02 |    10 |   -1.2e+00 |
|     4 | prob004 | success |  8.1e-01 |  4.3e+01 |    80 |   -8.8e-01 |
|     5 | prob005 | success | -3.5e-01 |  2.7e+02 |    30 |   -4.9e-01 |
|     6 | prob006 | success | -1.9e-01 |  6.7e+01 |    80 |    5.1e-01 |
|     7 | prob007 | success | -1.6e+00 |  1.6e+02 |    60 |   -7.6e-01 |
|     8 | prob008 | success | -2.5e+00 |  6.1e+02 |    40 |   -7.7e-01 |
|     9 | prob009 | success |  2.3e+00 |  1.4e+02 |    40 |   -3.0e-02 |
|    10 | prob010 | failure |  2.2e-01 |  8.4e+02 |    50 |   -1.3e+00 |</code></pre><pre><code class="language-julia">latex_table(stdout, stats[:alpha])</code></pre><pre><code class="language-none">\begin{longtable}[c]{lrrrrrr}
\hline
id &amp; name &amp; status &amp; f &amp; t &amp; iter &amp; irrelevant \\
\hline
\endfirsthead
\multicolumn{7}{l}
{{\bfseries \tablename\ \thetable{} --- continued from previous page}} \\
\hline
id &amp; name &amp; status &amp; f &amp; t &amp; iter &amp; irrelevant \\
\hline
\endhead
\hline
\multicolumn{7}{r}{{\bfseries Continued on next page}} \\
\hline
\endfoot
\hline
\endlastfoot
\(    1\) &amp; prob001 &amp; failure &amp; \(-6.9\)e\(-01\) &amp; \( 6.2\)e\(+01\) &amp; \(   70\) &amp; \( 8.9\)e\(-01\) \\
\(    2\) &amp; prob002 &amp; failure &amp; \(-7.6\)e\(-01\) &amp; \( 3.5\)e\(+02\) &amp; \(   10\) &amp; \(-2.3\)e\(+00\) \\
\(    3\) &amp; prob003 &amp; success &amp; \( 4.0\)e\(-01\) &amp; \( 7.7\)e\(+02\) &amp; \(   10\) &amp; \(-1.2\)e\(+00\) \\
\(    4\) &amp; prob004 &amp; success &amp; \( 8.1\)e\(-01\) &amp; \( 4.3\)e\(+01\) &amp; \(   80\) &amp; \(-8.8\)e\(-01\) \\
\(    5\) &amp; prob005 &amp; success &amp; \(-3.5\)e\(-01\) &amp; \( 2.7\)e\(+02\) &amp; \(   30\) &amp; \(-4.9\)e\(-01\) \\
\(    6\) &amp; prob006 &amp; success &amp; \(-1.9\)e\(-01\) &amp; \( 6.7\)e\(+01\) &amp; \(   80\) &amp; \( 5.1\)e\(-01\) \\
\(    7\) &amp; prob007 &amp; success &amp; \(-1.6\)e\(+00\) &amp; \( 1.6\)e\(+02\) &amp; \(   60\) &amp; \(-7.6\)e\(-01\) \\
\(    8\) &amp; prob008 &amp; success &amp; \(-2.5\)e\(+00\) &amp; \( 6.1\)e\(+02\) &amp; \(   40\) &amp; \(-7.7\)e\(-01\) \\
\(    9\) &amp; prob009 &amp; success &amp; \( 2.3\)e\(+00\) &amp; \( 1.4\)e\(+02\) &amp; \(   40\) &amp; \(-3.0\)e\(-02\) \\
\(   10\) &amp; prob010 &amp; failure &amp; \( 2.2\)e\(-01\) &amp; \( 8.4\)e\(+02\) &amp; \(   50\) &amp; \(-1.3\)e\(+00\) \\
\hline
\end{longtable}</code></pre><p>Alternatively, you can print to a file.</p><pre><code class="language-julia">open(&quot;alpha.tex&quot;, &quot;w&quot;) do io
  println(io, &quot;\\documentclass[varwidth=20cm,crop=true]{standalone}&quot;)
  println(io, &quot;\\usepackage{longtable}&quot;)
  println(io, &quot;\\begin{document}&quot;)
  latex_table(io, stats[:alpha])
  println(io, &quot;\\end{document}&quot;)
end</code></pre><pre><code class="language-julia">run(`latexmk -quiet -pdf alpha.tex`)
run(`pdf2svg alpha.pdf alpha.svg`)</code></pre><pre><code class="language-none">Process(`pdf2svg alpha.pdf alpha.svg`, ProcessExited(0))</code></pre><p><img src="../alpha.svg" alt/></p><p>The main options for both <code>table</code> commands is <code>cols</code>, which defines which columns to use.</p><pre><code class="language-julia">markdown_table(stdout, stats[:alpha], cols=[:name, :f, :t])</code></pre><pre><code class="language-none">|    name |        f |        t |
|---------|----------|----------|
| prob001 | -6.9e-01 |  6.2e+01 |
| prob002 | -7.6e-01 |  3.5e+02 |
| prob003 |  4.0e-01 |  7.7e+02 |
| prob004 |  8.1e-01 |  4.3e+01 |
| prob005 | -3.5e-01 |  2.7e+02 |
| prob006 | -1.9e-01 |  6.7e+01 |
| prob007 | -1.6e+00 |  1.6e+02 |
| prob008 | -2.5e+00 |  6.1e+02 |
| prob009 |  2.3e+00 |  1.4e+02 |
| prob010 |  2.2e-01 |  8.4e+02 |</code></pre><p>Notice that passing a column that does not exist will throw an error, but you can pass <code>ignore_missing_cols=true</code> to simply ignore that column.</p><p>The <code>fmt_override</code> option overrides the formatting of a specific column. The  argument should be a dictionary of <code>Symbol</code> to functions, where the functions will be applied to each element of the column.</p><p>The <code>hdr_override</code> simply changes the name of the column.</p><pre><code class="language-julia">fmt_override = Dict(:f =&gt; x-&gt;@sprintf(&quot;%+10.3e&quot;, x),
                    :t =&gt; x-&gt;@sprintf(&quot;%08.2f&quot;, x))
hdr_override = Dict(:name =&gt; &quot;Name&quot;, :f =&gt; &quot;f(x)&quot;, :t =&gt; &quot;Time&quot;)
markdown_table(stdout, stats[:alpha], cols=[:name, :f, :t], fmt_override=fmt_override, hdr_override=hdr_override)</code></pre><pre><code class="language-none">|    Name |       f(x) |     Time |
|---------|------------|----------|
| prob001 | -6.889e-01 | 00062.37 |
| prob002 | -7.628e-01 | 00353.13 |
| prob003 | +3.975e-01 | 00767.60 |
| prob004 | +8.116e-01 | 00043.14 |
| prob005 | -3.464e-01 | 00267.99 |
| prob006 | -1.876e-01 | 00066.85 |
| prob007 | -1.607e+00 | 00156.64 |
| prob008 | -2.481e+00 | 00605.30 |
| prob009 | +2.276e+00 | 00135.75 |
| prob010 | +2.197e-01 | 00838.12 |</code></pre><p>This allows for elaborate things, such as</p><pre><code class="language-julia">function time_fmt(x)
  xi = floor(Int, x)
  minutes = div(xi, 60)
  seconds = xi % 60
  micros  = round(Int, 1e6 * (x - xi))
  @sprintf(&quot;%2dm %02ds %06dμs&quot;, minutes, seconds, micros)
end
fmt_override = Dict(:f =&gt; x-&gt;@sprintf(&quot;%+10.3e&quot;, x), :t =&gt; time_fmt)
hdr_override = Dict(:name =&gt; &quot;Name&quot;, :f =&gt; &quot;f(x)&quot;, :t =&gt; &quot;Time&quot;)
markdown_table(stdout, stats[:alpha], cols=[:name, :f, :t], fmt_override=fmt_override, hdr_override=hdr_override)</code></pre><pre><code class="language-none">|    Name |       f(x) |             Time |
|---------|------------|------------------|
| prob001 | -6.889e-01 |  1m 02s 368558μs |
| prob002 | -7.628e-01 |  5m 53s 129773μs |
| prob003 | +3.975e-01 | 12m 47s 602896μs |
| prob004 | +8.116e-01 |  0m 43s 142023μs |
| prob005 | -3.464e-01 |  4m 27s 985634μs |
| prob006 | -1.876e-01 |  1m 06s 847444μs |
| prob007 | -1.607e+00 |  2m 36s 637637μs |
| prob008 | -2.481e+00 | 10m 05s 297740μs |
| prob009 | +2.276e+00 |  2m 15s 745559μs |
| prob010 | +2.197e-01 | 13m 58s 118754μs |</code></pre><p>Notice that for <code>latex_table</code>, the output must be understood by the LaTeX compiler. To that end, we have a few functions that convert a specific element into a LaTeX-safe string: <a href="../api/#SolverBenchmark.safe_latex_AbstractFloat"><code>safe_latex_AbstractFloat</code></a>, <a href="../api/#SolverBenchmark.safe_latex_AbstractString"><code>safe_latex_AbstractString</code></a>, <a href="../api/#SolverBenchmark.safe_latex_Symbol"><code>safe_latex_Symbol</code></a> and <a href="../api/#SolverBenchmark.safe_latex_Signed"><code>safe_latex_Signed</code></a>.</p><pre><code class="language-julia">function time_fmt(x)
  xi = floor(Int, x)
  minutes = div(xi, 60)
  seconds = xi % 60
  micros  = round(Int, 1e6 * (x - xi))
  @sprintf(&quot;\\(%2d\\)m \\(%02d\\)s \\(%06d\\mu s\\)&quot;, minutes, seconds, micros)
end
fmt_override = Dict(:f =&gt; x-&gt;@sprintf(&quot;%+10.3e&quot;, x) |&gt; safe_latex_AbstractFloat,
                    :t =&gt; time_fmt)
hdr_override = Dict(:name =&gt; &quot;Name&quot;, :f =&gt; &quot;\\(f(x)\\)&quot;, :t =&gt; &quot;Time&quot;)
open(&quot;alpha2.tex&quot;, &quot;w&quot;) do io
  println(io, &quot;\\documentclass[varwidth=20cm,crop=true]{standalone}&quot;)
  println(io, &quot;\\usepackage{longtable}&quot;)
  println(io, &quot;\\begin{document}&quot;)
  latex_table(io, stats[:alpha], cols=[:name, :f, :t], fmt_override=fmt_override, hdr_override=hdr_override)
  println(io, &quot;\\end{document}&quot;)
end</code></pre><p><img src="../alpha2.svg" alt/></p><h3 id="Joining-tables-1"><a class="docs-heading-anchor" href="#Joining-tables-1">Joining tables</a><a class="docs-heading-anchor-permalink" href="#Joining-tables-1" title="Permalink"></a></h3><p>In some occasions, instead of/in addition to showing individual results, we show a table with the result of multiple solvers.</p><pre><code class="language-julia">df = join(stats, [:f, :t])
markdown_table(stdout, df)</code></pre><pre><code class="language-none">|    id |  f_alpha |  t_alpha |   f_beta |   t_beta |  f_gamma |  t_gamma |
|-------|----------|----------|----------|----------|----------|----------|
|     1 | -6.9e-01 |  6.2e+01 | -1.1e+00 |  1.8e+02 |  6.3e-02 |  3.3e+01 |
|     2 | -7.6e-01 |  3.5e+02 |  8.2e-01 |  8.0e+01 |  1.2e-01 |  6.9e+02 |
|     3 |  4.0e-01 |  7.7e+02 |  1.5e-01 |  6.8e+02 |  2.7e+00 |  8.4e+02 |
|     4 |  8.1e-01 |  4.3e+01 | -3.3e-01 |  9.3e+02 | -6.9e-01 |  1.9e+02 |
|     5 | -3.5e-01 |  2.7e+02 |  1.4e+00 |  9.7e+02 | -5.5e-02 |  1.6e+02 |
|     6 | -1.9e-01 |  6.7e+01 | -4.4e-01 |  6.5e+02 |  4.2e-01 |  9.0e+02 |
|     7 | -1.6e+00 |  1.6e+02 |  1.1e+00 |  6.0e+02 | -1.4e+00 |  9.5e+01 |
|     8 | -2.5e+00 |  6.1e+02 | -2.5e-01 |  4.8e+02 | -4.5e-01 |  7.8e+02 |
|     9 |  2.3e+00 |  1.4e+02 |  2.9e-01 |  6.3e+01 | -8.8e-01 |  8.7e+02 |
|    10 |  2.2e-01 |  8.4e+02 | -3.5e+00 |  4.7e+02 |  1.1e+00 |  8.4e+02 |</code></pre><p>The column <code>:id</code> is used as guide on where to join. In addition, we may have repeated columns between the solvers. We convery that information with argument <code>invariant_cols</code>.</p><pre><code class="language-julia">df = join(stats, [:f, :t], invariant_cols=[:name])
markdown_table(stdout, df)</code></pre><pre><code class="language-none">|    id |    name |  f_alpha |  t_alpha |   f_beta |   t_beta |  f_gamma |  t_gamma |
|-------|---------|----------|----------|----------|----------|----------|----------|
|     1 | prob001 | -6.9e-01 |  6.2e+01 | -1.1e+00 |  1.8e+02 |  6.3e-02 |  3.3e+01 |
|     2 | prob002 | -7.6e-01 |  3.5e+02 |  8.2e-01 |  8.0e+01 |  1.2e-01 |  6.9e+02 |
|     3 | prob003 |  4.0e-01 |  7.7e+02 |  1.5e-01 |  6.8e+02 |  2.7e+00 |  8.4e+02 |
|     4 | prob004 |  8.1e-01 |  4.3e+01 | -3.3e-01 |  9.3e+02 | -6.9e-01 |  1.9e+02 |
|     5 | prob005 | -3.5e-01 |  2.7e+02 |  1.4e+00 |  9.7e+02 | -5.5e-02 |  1.6e+02 |
|     6 | prob006 | -1.9e-01 |  6.7e+01 | -4.4e-01 |  6.5e+02 |  4.2e-01 |  9.0e+02 |
|     7 | prob007 | -1.6e+00 |  1.6e+02 |  1.1e+00 |  6.0e+02 | -1.4e+00 |  9.5e+01 |
|     8 | prob008 | -2.5e+00 |  6.1e+02 | -2.5e-01 |  4.8e+02 | -4.5e-01 |  7.8e+02 |
|     9 | prob009 |  2.3e+00 |  1.4e+02 |  2.9e-01 |  6.3e+01 | -8.8e-01 |  8.7e+02 |
|    10 | prob010 |  2.2e-01 |  8.4e+02 | -3.5e+00 |  4.7e+02 |  1.1e+00 |  8.4e+02 |</code></pre><p><code>join</code> also accepts <code>hdr_override</code> for changing the column name before appending <code>_solver</code>.</p><pre><code class="language-julia">hdr_override = Dict(:name =&gt; &quot;Name&quot;, :f =&gt; &quot;f(x)&quot;, :t =&gt; &quot;Time&quot;)
df = join(stats, [:f, :t], invariant_cols=[:name], hdr_override=hdr_override)
markdown_table(stdout, df)</code></pre><pre><code class="language-none">|    id |    name | f(x)_alpha | Time_alpha | f(x)_beta | Time_beta | f(x)_gamma | Time_gamma |
|-------|---------|------------|------------|-----------|-----------|------------|------------|
|     1 | prob001 |   -6.9e-01 |    6.2e+01 |  -1.1e+00 |   1.8e+02 |    6.3e-02 |    3.3e+01 |
|     2 | prob002 |   -7.6e-01 |    3.5e+02 |   8.2e-01 |   8.0e+01 |    1.2e-01 |    6.9e+02 |
|     3 | prob003 |    4.0e-01 |    7.7e+02 |   1.5e-01 |   6.8e+02 |    2.7e+00 |    8.4e+02 |
|     4 | prob004 |    8.1e-01 |    4.3e+01 |  -3.3e-01 |   9.3e+02 |   -6.9e-01 |    1.9e+02 |
|     5 | prob005 |   -3.5e-01 |    2.7e+02 |   1.4e+00 |   9.7e+02 |   -5.5e-02 |    1.6e+02 |
|     6 | prob006 |   -1.9e-01 |    6.7e+01 |  -4.4e-01 |   6.5e+02 |    4.2e-01 |    9.0e+02 |
|     7 | prob007 |   -1.6e+00 |    1.6e+02 |   1.1e+00 |   6.0e+02 |   -1.4e+00 |    9.5e+01 |
|     8 | prob008 |   -2.5e+00 |    6.1e+02 |  -2.5e-01 |   4.8e+02 |   -4.5e-01 |    7.8e+02 |
|     9 | prob009 |    2.3e+00 |    1.4e+02 |   2.9e-01 |   6.3e+01 |   -8.8e-01 |    8.7e+02 |
|    10 | prob010 |    2.2e-01 |    8.4e+02 |  -3.5e+00 |   4.7e+02 |    1.1e+00 |    8.4e+02 |</code></pre><pre><code class="language-julia">hdr_override = Dict(:name =&gt; &quot;Name&quot;, :f =&gt; &quot;\\(f(x)\\)&quot;, :t =&gt; &quot;Time&quot;)
df = join(stats, [:f, :t], invariant_cols=[:name], hdr_override=hdr_override)
open(&quot;alpha3.tex&quot;, &quot;w&quot;) do io
  println(io, &quot;\\documentclass[varwidth=20cm,crop=true]{standalone}&quot;)
  println(io, &quot;\\usepackage{longtable}&quot;)
  println(io, &quot;\\begin{document}&quot;)
  latex_table(io, df)
  println(io, &quot;\\end{document}&quot;)
end</code></pre><p><img src="../alpha3.svg" alt/></p><h2 id="Profiles-1"><a class="docs-heading-anchor" href="#Profiles-1">Profiles</a><a class="docs-heading-anchor-permalink" href="#Profiles-1" title="Permalink"></a></h2><p>Performance profiles are a comparison tool developed by <a href="https://link.springer.com/article/10.1007/s101070100263">Dolan and Moré, 2002</a> that takes into account the relative performance of a solver and whether it has achieved convergence for each problem. <code>SolverBenchmark.jl</code> uses <a href="https://github.com/JuliaSmoothOptimizers/BenchmarkProfiles.jl">BenchmarkProfiles.jl</a> for generating performance profiles from the dictionary of <code>DataFrame</code>s.</p><p>The basic usage is <code>performance_profile(stats, cost)</code>, where <code>cost</code> is a function applied to a <code>DataFrame</code> and returning a vector.</p><pre><code class="language-none">using Plots
pyplot()

p = performance_profile(stats, df -&gt; df.t)
Plots.svg(p, &quot;profile1&quot;)</code></pre><p><img src="../profile1.svg" alt/></p><p>Notice that we used <code>df -&gt; df.t</code> which corresponds to the column <code>:t</code> of the <code>DataFrame</code>s. This does not take into account that the solvers have failed for a few problems (according to column :status). The next profile takes that into account.</p><pre><code class="language-none">cost(df) = (df.status .!= :success) * Inf + df.t
p = performance_profile(stats, cost)
Plots.svg(p, &quot;profile2&quot;)</code></pre><p><img src="../profile2.svg" alt/></p><h3 id="Profile-wall-1"><a class="docs-heading-anchor" href="#Profile-wall-1">Profile wall</a><a class="docs-heading-anchor-permalink" href="#Profile-wall-1" title="Permalink"></a></h3><p>Another profile function is <code>profile_solvers</code>, which creates a wall of performance profiles, accepting multiple costs and doing 1 vs 1 comparisons in addition to the traditional performance profile.</p><pre><code class="language-none">solved(df) = (df.status .== :success)
costs = [df -&gt; .!solved(df) * Inf + df.t, df -&gt; .!solved(df) * Inf + df.iter]
costnames = [&quot;Time&quot;, &quot;Iterations&quot;]
p = profile_solvers(stats, costs, costnames)
Plots.svg(p, &quot;profile3&quot;)</code></pre><p><img src="../profile3.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 15 April 2020 02:21">Wednesday 15 April 2020</span>. Using Julia version 1.1.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
